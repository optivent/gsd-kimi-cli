# Phase 1 Plan: Project Bootstrap & Architecture

## Goal
Establish solid foundation with architecture decisions, development environment, and project structure - using GSD-patched kimi-cli as our stable testing and reference platform.

## Stable Base Strategy

### Development Environment
```
┌─────────────────────────────────────────────────────────────┐
│  Host: GSD-Patched kimi-cli (STABLE - Already Working)      │
│  ├── Use for: Testing, reference, fallback                  │
│  ├── Run: `/skill:gsd-*` commands                           │
│  └── Provides: Working GSD implementation to study          │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  Development: Elixir Project (kimi_gsd_ex/)                 │
│  ├── Built alongside stable version                         │
│  ├── Tested via stable CLI integration                      │
│  └── Incremental feature parity                             │
└─────────────────────────────────────────────────────────────┘
```

### Testing Methodology

#### From Within Stable CLI
```bash
# Terminal 1: Run stable GSD-patched kimi-cli
$ jim

# Use GSD commands to manage the project
/skill:gsd-progress          # Check current state
/skill:gsd-execute-flow      # Execute plans
/skill:gsd-verify-work       # Verify completion

# Terminal 2: Develop Elixir components
$ cd ~/kimi_gsd_ex
$ mix test                   # Test Elixir code
$ iex -S mix                 # Interactive development
```

#### Side-by-Side Comparison
```
Stable Python (Reference)          Elixir (Development)
    ↓                                    ↓
Load GSD context                Load GSD context
(2-5ms file I/O)                (<0.001ms cache)
    ↓                                    ↓
Render status bar               Render status bar
    ↓                                    ↓
Compare: Should match!          Verify: Faster?
```

## Phase Overview
This phase sets up the entire project infrastructure. Get it right here, everything else flows smoothly. Get it wrong, technical debt accumulates fast.

---

## Task 1: Architecture Design
**Status:** ⏳ Ready  
**Assignee:** gsd-roadmapper + gsd-phase-researcher  
**Priority:** CRITICAL  
**Duration:** 3-4 days

### Subtasks

#### 1.1 Domain-Driven Design
Study the stable GSD implementation:
- [ ] Review current Python GSD patches
  - Location: `~/.local/share/uv/tools/kimi-cli/lib/python3.13/site-packages/kimi_cli/`
  - Files: soul/__init__.py, kimisoul.py, shell/__init__.py, prompt.py
  - Document current behavior as specification

- [ ] Define bounded contexts
  - ChatContext: Message handling, streaming, history
  - GSDContext: Project, phase, milestone, todo management
  - SkillsContext: Skill registry, execution, supervision
  - LLMContext: Provider abstraction, rate limiting, caching
  - UIContext: Terminal, web dashboard, notifications

- [ ] Design aggregate roots
  - Session aggregate
  - Project aggregate
  - Skill execution aggregate

- [ ] Define domain events
  - MessageReceived, MessageSent
  - PhaseStarted, PhaseCompleted, PhaseFailed
  - SkillStarted, SkillCompleted, SkillFailed
  - StateChanged, MilestoneReached

#### 1.2 OTP Architecture
Reference the stable implementation patterns:
- [ ] Design supervision trees
  - Application supervisor
  - GSD supervisor tree (match Python patch structure)
  - Skills supervisor tree
  - Session supervisor tree

- [ ] Design GenServer interactions
  - Session manager (process registry)
  - State managers (one per project)
  - LLM gateway (connection pooling)

- [ ] Design ETS tables
  - :session_cache - Active sessions
  - :project_cache - Project states (replaces file reads)
  - :skill_cache - Skill definitions
  - :metrics_cache - Runtime metrics

#### 1.3 Data Flow Design
Study how stable CLI handles data:
- [ ] Request flow (user input → response)
  - Reference: `kimi_cli/ui/shell/prompt.py`
  - Replicate in Elixir with improvements
  
- [ ] Skill execution flow
  - Reference: GSD skill execution
  - Parallel vs sequential handling
  
- [ ] GSD state update flow
  - Reference: `_load_gsd_context()` implementation
  - Cache invalidation strategy
  
- [ ] Error handling flow
  - Reference: Current error handling in patches
  - Improve with OTP supervision

### Deliverables
- `adr/001-architecture-overview.md`
- `adr/002-domain-design.md`
- `adr/003-otp-supervision.md`
- `adr/004-data-flow.md`
- Architecture diagrams (Mermaid/C4)
- **Reference analysis document**: How stable GSD works

### Verification
- [ ] Architecture review with team
- [ ] All bounded contexts defined
- [ ] Supervision tree documented
- [ ] Data flows validated against stable implementation
- [ ] Side-by-side comparison document

---

## Task 2: Development Environment Setup
**Status:** ⏳ Ready  
**Assignee:** gsd-executor  
**Priority:** CRITICAL  
**Duration:** 2-3 days

### Subtasks

#### 2.1 Elixir Project Structure
```
kimi_gsd_ex/                    # New Elixir project
├── apps/
│   ├── kimi_core/              # Core business logic
│   ├── kimi_gsd/               # GSD domain (native implementation)
│   ├── kimi_skills/            # Skills framework
│   ├── kimi_ui/                # Terminal + Web UI
│   └── kimi_cli/               # CLI entry point
├── config/
├── deps/
├── docs/
├── scripts/
├── test/
├── mix.exs
└── README.md

../kimi_gsd/                    # Existing stable project (reference)
├── .planning/                  # GSD state (shared)
├── gsd-kimi-cli/               # Python patches (reference)
└── .kimi-todos.json            # Todo tracking
```

- [ ] Create umbrella app structure
- [ ] Configure each app
- [ ] Set up inter-app dependencies
- [ ] Link to stable GSD project for reference

#### 2.2 Tooling Setup
- [ ] Elixir/OTP version (latest stable)
- [ ] Formatter configuration (.formatter.exs)
- [ ] Credo for static analysis
- [ ] Dialyzer for type checking
- [ ] ExDoc for documentation
- [ ] Git hooks (pre-commit formatting)

#### 2.3 Development Tools
- [ ] Docker Compose for local development
- [ ] Dev container configuration
- [ ] VS Code extensions recommendations
- [ ] Makefile for common tasks
  ```makefile
  # Example targets
  setup:          # Initial setup
  test:           # Run tests
  test-watch:     # Run tests on change
  gsd-compare:    # Compare with stable GSD
  gsd-test:       # Test GSD features
  docs:           # Generate docs
  release:        # Build release
  ```
- [ ] Live reload for development

#### 2.4 Integration with Stable CLI
- [ ] Script to start Elixir services from stable CLI
- [ ] Environment variable to switch implementations
- [ ] Health check endpoint
- [ ] Feature flag system

### Deliverables
- Complete project skeleton
- Working `mix deps.get` and `mix compile`
- Development environment documented
- Docker Compose setup
- Integration scripts with stable CLI

### Verification
- [ ] Fresh clone → `make setup` → working dev environment
- [ ] All checks pass: `mix format --check-formatted`, `mix credo`, `mix dialyzer`
- [ ] Documentation builds: `mix docs`
- [ ] Can run from within stable GSD-patched CLI
- [ ] Side-by-side comparison works

---

## Task 3: CI/CD Pipeline
**Status:** ⏳ Ready  
**Assignee:** gsd-executor  
**Priority:** HIGH  
**Duration:** 2-3 days

### Subtasks

#### 3.1 GitHub Actions
- [ ] PR workflow
  - Compile check
  - Format check
  - Credo analysis
  - Dialyzer type check
  - Test suite
  - Coverage report
  - **Parity check**: Compare with stable GSD output

- [ ] Main branch workflow
  - All PR checks
  - Release build
  - Docker image build
  - Documentation deploy

- [ ] Release workflow
  - Version bump
  - Changelog generation
  - GitHub release
  - Hex.pm publish

#### 3.2 Testing Infrastructure
- [ ] ExUnit configuration
- [ ] Test categorization (unit, integration, e2e)
- [ ] Test coverage tracking (Codecov)
- [ ] Property-based testing (StreamData)
- [ ] Load testing (Wrk/Chaperon)
- [ ] **Parity tests**: Compare Elixir output with stable Python
  ```elixir
  test "GSD context matches stable implementation" do
    # Load context from stable Python
    stable = run_python_gsd_context()
    
    # Load context from Elixir
    elixir = GSD.Context.load()
    
    # Should match (except for timing/cache)
    assert elixir.phase == stable.phase
    assert elixir.project == stable.project
    assert elixir.todos_total == stable.todos_total
  end
  ```

#### 3.3 Quality Gates
- [ ] Minimum 80% test coverage
- [ ] No Credo warnings
- [ ] All Dialyzer checks pass
- [ ] Performance benchmarks met
- [ ] **Parity with stable GSD verified**

### Deliverables
- `.github/workflows/ci.yml`
- `.github/workflows/release.yml`
- Test infrastructure
- Quality gate configuration
- Parity test suite

### Verification
- [ ] PR triggers all checks
- [ ] Failed checks block merge
- [ ] Release process automated
- [ ] Coverage reported on PRs
- [ ] Parity tests pass

---

## Task 4: Documentation Framework
**Status:** ⏳ Ready  
**Assignee:** gsd-executor  
**Priority:** HIGH  
**Duration:** 1-2 days

### Subtasks

#### 4.1 Documentation Structure
```
docs/
├── README.md
├── ARCHITECTURE.md
├── DEVELOPMENT.md
│   └── Using stable GSD as reference
├── DEPLOYMENT.md
├── MIGRATION.md              # From Python to Elixir
├── api/
│   ├── core.md
│   ├── gsd.md
│   └── skills.md
├── adr/                      # Architecture Decision Records
├── guides/
│   ├── installation.md
│   ├── quickstart.md
│   └── advanced.md
└── reference/
    ├── python-gsd-analysis.md    # How stable version works
    └── elixir-porting-guide.md   # Mapping Python→Elixir
```

#### 4.2 Documentation Standards
- [ ] ADR template
- [ ] API documentation format
- [ ] Code documentation (ExDoc)
- [ ] User guide structure
- [ ] **Reference documentation**: Stable GSD behavior

#### 4.3 Documentation Automation
- [ ] Auto-generate API docs
- [ ] Auto-deploy to GitHub Pages
- [ ] Link checking
- [ ] Documentation coverage

### Deliverables
- Documentation structure
- Templates and standards
- Automated publishing
- Reference analysis of stable GSD

### Verification
- [ ] `mix docs` generates comprehensive docs
- [ ] GitHub Pages auto-updates
- [ ] All public functions documented
- [ ] Stable GSD behavior documented

---

## Integration Testing with Stable CLI

### Test Setup
```bash
# Terminal 1: Stable GSD-patched CLI
$ cd /Users/aig/kimi_gsd
$ jim

# Check current state
/skill:gsd-progress

# Terminal 2: Elixir development
$ cd ~/kimi_gsd_ex
$ mix deps.get
$ iex -S mix

# Test GSD context loading
iex> GSD.Context.load()
%GSD.Context{
  phase: "3",
  project: "Kimi GSD Project",
  todos_total: 15,
  todos_done: 11,
  ...
}

# Compare with stable
iex> GSD.Testing.compare_with_stable()
:ok  # Outputs match!
```

### Continuous Comparison
```elixir
# In test suite
defmodule GSD.ParityTest do
  use ExUnit.Case
  
  test "context loading matches stable implementation" do
    # Run stable Python version
    stable_output = System.cmd("python3", [
      "-c",
      "from kimi_cli.gsd import load_context; print(load_context())"
    ])
    
    # Run Elixir version
    elixir_output = GSD.Context.load() |> inspect()
    
    # Compare (accounting for formatting differences)
    assert equivalent?(stable_output, elixir_output)
  end
end
```

---

## Verification Criteria

- [ ] Architecture ADRs approved
- [ ] Project compiles without warnings
- [ ] CI/CD pipeline green
- [ ] Development environment documented
- [ ] Team can onboard in <30 minutes
- [ ] **Can run from stable GSD-patched CLI**
- [ ] **Parity with stable implementation verified**

## Dependencies
- ✅ Phase 1-2 of original GSD project (stable base)
- ✅ GSD-patched kimi-cli (reference implementation)

## Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| Wrong architecture | HIGH | Multiple design reviews, compare with stable |
| Tooling issues | MEDIUM | Use proven tools, fallback options |
| Scope creep | MEDIUM | Strict phase boundaries, timeboxing |
| Parity gaps | MEDIUM | Continuous comparison testing |

## Notes

**Extreme Thinking Applied:**
- Don't just "set up Elixir project" - design for 1000-node cluster from day 1
- Don't just "write tests" - build quality gates that enforce parity with stable
- Don't just "document code" - create living documentation including stable behavior
- **Use stable GSD as north star** - always have working reference

**Key Decisions Needed:**
1. Umbrella vs mono-repo?
2. Which UI library? (ratatouille, scenic, or custom?)
3. Which PubSub? (Phoenix.PubSub, Nats, or custom?)
4. Storage? (ETS-only, or add Postgres/Mnesia?)
5. **How to integrate with stable CLI for testing?**

**Time Budget:** 8-12 days
**Team Size:** 2 developers
